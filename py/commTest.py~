#!/usr/bin/python

import sys,os
from commAux import CommAux
from datetime import datetime

############################################################
# START FROM HERE!
#dIS is hbar gammaIgammaS / 4pi e0 r^6
#csa is hbar ((parallel-permendicular) * gamma * B0)/3
#J(teff,w) is teff/(1+wc^2teff^2) - Kay type - numerical constants are as stated
#P20=1/2(3cos^2b-1) #polynomial
#P21=(3sinbcosb) #polynomial
#P22=(3sin^2b)    #polynomial
#
#To use:
# first make a basis.
# then construct the desired Hamiltonian from dipolar and CSA terms
# then evaluate the spectral density functions. Options here include:
#    -kay True -approximate the functions with (3cos^2t-1) angles
#    -kay False -use explicit geometry
#    -macro True - take macromolecular limit - tauM terms-> taum, high frequencies set to zero.
#    -macro False - don't take macrmolecular limit
#    -taum 'taum' - allow for methyl tumbling
#    -taum 0     -don't allow for methyl tumbling
# After spectral density funcitons have been constructed, calculate desired relaxation rates.
# Have fun!
############################################################

def DoCHtest():
    import numpy,basis
    print 'Calculating CH'
    inst=CommAux('CH')
    rot='static'
    #rot='rot'
    
    inst.GetDip('H2','C1','d',beta=0,alpha=0,rot=rot)
    inst.GetCSA('C1','cA',beta='beta',alpha=0,rot=rot)
    inst.GetCSA('H2','cX',beta='beta',alpha=0,rot=rot)

    inst.macro=False

    inst.CrossCorrHam()
    inst.EvalRate('H2aC1m','H2aC1m',verb='n')  #correct
    inst.EvalRate('H2bC1m','H2aC1m')  #correct
    inst.EvalRate('H2bC1m','H2bC1m')  #correct
    inst.EvalRate('C1m','C1m')  #correct
    inst.EvalRate('H2m','H2m')  #correct
    inst.EvalRate('H2z','H2z')  #correct
    inst.EvalRate('H2z','C1z')  #correct
    inst.EvalRate('H2p','C1p')  #correct
    inst.EvalRate('H2zC1x','H2zC1x')  #correct
    inst.EvalRate('H2xC1x','H2xC1x')  #correct

    inst.base=basis.GetBasis('CH')  #get complete basis

    inst.base['IzPSz']=inst.base['H2z']+inst.base['C1z']
    inst.base['IzMSz']=inst.base['H2z']-inst.base['C1z']

    inst.CheckComm(1/4.,'H2pC1p','H2mC1m','H2p')
    inst.CheckComm(1/4.,'H2mC1m','H2pC1p','H2p')
    inst.CheckComm(1/4.,'H2zC1p','H2zC1m','H2p')
    inst.CheckComm(1/4.,'H2zC1m','H2zC1p','H2p')
    inst.CheckComm(1/4.,'H2pC1z','H2mC1z','H2p')
    inst.CheckComm(1/4.,'H2mC1z','H2pC1z','H2p')
    inst.CheckComm(2/3.,'H2zC1z','H2zC1z','H2p')
    inst.CheckComm(1/24.,'H2mC1p','H2pC1m','H2p')
    inst.CheckComm(1/24.,'H2pC1m','H2mC1p','H2p')
    

    print basis.compare(numpy.dot(inst.base['H2z'],inst.base['H2z']),inst.base)
    print basis.compare(numpy.dot(inst.base['H2a'],inst.base['H2b']),inst.base)
    print basis.compare(numpy.dot(inst.base['H2a'],inst.base['H2a']),inst.base)
    print basis.compare(numpy.dot(inst.base['H2b'],inst.base['H2a']),inst.base)
    print basis.compare(numpy.dot(inst.base['H2b'],inst.base['H2b']),inst.base)

    inst.CheckComm(1/4.,'H2pC1p','H2mC1m','H2z')
    inst.CheckComm(1/4.,'H2mC1m','H2pC1p','H2z')
    inst.CheckComm(1/4.,'H2zC1p','H2zC1m','H2z')
    inst.CheckComm(1/4.,'H2zC1m','H2zC1p','H2z')
    inst.CheckComm(1/4.,'H2pC1z','H2mC1z','H2z')
    inst.CheckComm(1/4.,'H2mC1z','H2pC1z','H2z')
    inst.CheckComm(2/3.,'H2zC1z','H2zC1z','H2z')
    inst.CheckComm(1/24.,'H2mC1p','H2pC1m','H2z')
    inst.CheckComm(1/24.,'H2pC1m','H2mC1p','H2z')
    inst.CloseLatex()

def DoCH(macro=True,ax=True,xx=True,cx=True,ca=True,sparse=True,sym=True):

    print 'Calculating CH'
    inst=CommAux('CH',sparse=sparse,sym=sym)

    rot='static'
    #rot='rot'
    
    if(ax):
        inst.GetDip('H2','C1','d',beta=0,alpha=0,rot=rot)
    if(ca):
        inst.GetCSA('C1','cA',beta='beta',alpha=0,rot=rot)
    if(cx):
        inst.GetCSA('H2','cX',beta='beta',alpha=0,rot=rot)

    inst.macro=macro

    inst.pars['beta']=120
    inst.pars['R']=1.09E-10,'C','H'
    inst.pars['cX']=1.,'H'
    inst.pars['cA']=20.,'C'
    inst.SetPars('CH')

    inst.CrossCorrHam() #proceed to cross correlate
    testbasis=inst.GetBasisAXn(1) #assemble aaa,aab,abb,bbb basis
    testbasis.append('H2z')
    testbasis.append('H2p')
    testbasis.append('H2xC1m')
    testbasis.append('H2zC1m')
    for lab in testbasis:
        inst.EvalRate(lab,lab,verb='y',calc='y')
    inst.DoTcPlot(1E-6,1E-11,30,testbasis,'figCH.eps')
    inst.CloseLatex()

#################################

def DoCD(macro=False,ax=True,xx=True,cx=True,ca=True,qx=True,sparse=True,sym=True):
    print
    print 'Calculating CD'
    if(qx):  #no symbolic treatment for spin 1
        sym=False
        point=False

    rot='static'
    #rot='rot'

    inst=CommAux('CD',sparse=sparse,sym=sym)

    if(ax):
        inst.GetDip('D2','C1','d',beta=0,alpha=0,rot=rot)
    if(qx):
        inst.GetQuad('D2','Q',beta=0,alpha=0,rot=rot)
    if(ca):
        inst.GetCSA('C1','cA',beta=0,alpha=0,rot=rot)
    if(cx):
        inst.GetCSA('D2','cX',rot=rot)

    inst.macro=macro

    inst.CrossCorrHam()
    testbasis=inst.GetBasisAXn(1) #assemble aaa,aab,abb,bbb basis
    testbasis.append('D2xC1m')
    testbasis.append('D2zC1m')
    testbasis.append('D2z')
    testbasis.append('D2p')
    for lab in testbasis:
        inst.EvalRate(lab,lab,verb='y')

    inst.pars['beta']=120
    inst.pars['R']=1.09E-10,'C','D'
    inst.pars['cX']=1.,'D'
    inst.pars['cA']=20.,'C'
    inst.pars['Q']=1E-10
    inst.SetPars('CD')
    inst.DoTcPlot(1E-6,1E-11,30,testbasis,'figCH.eps')

    inst.CloseLatex()

#################################
def DoCH2(macro=False,ax=True,xx=True,cx=True,ca=True,sparse=True,sym=True,extH=False,extD=False,irreducible=False):
    print
    print 'Calculating CH2'
    rot='static'
    rot='rot'

    tag='CH2'
    if(extH):
        tag+='H'
    if(extD):
        sym=False
        tag+='D'

    inst=CommAux(tag,sparse=sparse,sym=sym)

    if(ax):
        inst.GetDip('H2','C1','d',beta='beta',alpha='1pi/2',rot=rot)
        inst.GetDip('H3','C1','d',beta='beta',alpha='3pi/2',rot=rot)
    if(xx):
        inst.GetDip('H3','H2','e',beta='pi/2',alpha='pi/2',rot=rot)
    if(ca):
        inst.GetCSA('C1','cA',rot=rot)
    if(cx):
        inst.GetCSA('H2','cX',beta='beta',alpha='1pi/2',rot=rot)
        inst.GetCSA('H3','cX',beta='beta',alpha='3pi/2',rot=rot)

    if(extH):
        inst.GetDip('H4','H2','f',beta=0,alpha=0,rot='ext')
        inst.GetDip('H4','H3','f',beta=0,alpha=0,rot='ext')
        inst.GetDip('H4','C1','g',beta=0,alpha=0,rot='ext')
        inst.GetDip('H4','C1','g',beta=0,alpha=0,rot='ext')

        if(extD):
            inst.GetDip('D5','H2','f',beta=0,alpha=0,rot='ext')
            inst.GetDip('D5','H3','f',beta=0,alpha=0,rot='ext')
            inst.GetDip('D5','C1','g',beta=0,alpha=0,rot='ext')
            inst.GetDip('D5','C1','g',beta=0,alpha=0,rot='ext')
    elif(extD):
        inst.GetDip('D4','H2','f',beta=0,alpha=0,rot='ext')
        inst.GetDip('D4','H3','f',beta=0,alpha=0,rot='ext')
        inst.GetDip('D4','C1','g',beta=0,alpha=0,rot='ext')
        inst.GetDip('D4','C1','g',beta=0,alpha=0,rot='ext')


    #inst.CrossCorrHamFull(Aint,kay=False,taum=0) #proceed to cross correlate
    #inst.GetDip('H2','C1','d1',beta=0,alpha=0)
    #inst.GetDip('H3','C1','d2',beta=0,alpha=0)
    #inst.GetDip('H3','H2','e1',beta=0,alpha=0)
    #inst.GetCSA('C1','cA')
    inst.macro=macro

    inst.pars['beta']=120
    inst.pars['R']=1.09E-10,'C','H'
    inst.pars['cX']=1.,'H'
    inst.pars['cA']=20.,'C'
    inst.pars['Rf']=3E-10,'H','H'
    inst.pars['Rg']=3E-10,'H','D'

    inst.SetPars('CH2')

    inst.CrossCorrHam() #proceed to cross correlate

    #TRANSFORM INTO IRREDUCIBLE REPRESENTATION & GET RATES
    if(extH==False and extD==False and irreducible==True):
        irrbasis=inst.IreducibleBasis()
        inst.DoTcPlot(1E-6,1E-11,30,irrbasis,'figIrr.eps')
        inst.tc=1E-8
        inst.tm=1E-11
        inst.DoBasisPlot(irrbasis,'figIrr2.eps')
    
    testbasis=inst.GetBasisAXn(2) #assemble paa,pab,pba,pbb basis
    #for lab in testbasis:
    #    inst.EvalRate(lab,lab,verb='y')

    inst.Assemble(('H2zC1z','H3zC1z'),'CzHz')
    inst.Assemble(('H3zH2zC1z',),'CzHzHz')
    inst.Assemble(('H3pC1a','H2pC1a',),'Ha')
    inst.Assemble(('H3pC1b','H2pC1b',),'Hb')

    testbasis.append('CzHz')
    testbasis.append('CzHzHz')
    testbasis.append('Ha')
    testbasis.append('Hb')

    inst.EvalRate(testbasis,testbasis,verb='y')

    #autoRates='1','2','3','4'

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    inst.pars['beta']=120
    inst.pars['R']=1.09E-10,'C','H'
    inst.pars['cX']=1.,'H'
    inst.pars['cA']=20.,'C'
    inst.pars['Rf']=3E-10,'H','H'
    inst.pars['Rg']=3E-10,'H','D'
    inst.DoTcPlot(1E-6,1E-11,30,testbasis,'figCH2_1.eps')
    inst.SetPars('CH2')
    inst.SetFreq(1200)  #MHz. Set spectrometer proton frequency
    inst.SetPars('CH2')
    inst.DoTcPlot(1E-6,1E-11,30,testbasis,'figCH2_3.eps')

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency

    inst.pars['beta']=120
    inst.pars['R']=1.35E-10,'C','F'
    inst.pars['cX']=140.,'F'
    inst.pars['cA']=20.,'C'
    inst.pars['Rf']=3E-10,'H','F'
    inst.pars['Rg']=3E-10,'H','D'
    inst.SetPars('CH2')
    inst.DoTcPlot(1E-6,1E-11,30,testbasis,'figCH2_2.eps')
    inst.SetFreq(1200)  #MHz. Set spectrometer proton frequency
    inst.SetPars('CH2')
    inst.DoTcPlot(1E-6,1E-11,30,testbasis,'figCH2_4.eps')


    for lab in testbasis:
        inst.TestForm(lab,lab,'rot')

    inst.MacroTable('rot',2)

    inst.CloseLatex()

    #inst.EvalRate(testbasis,testbasis,verb='y')


def DoCH3(macro=True,ax=True,xx=True,cx=True,ca=True,extH=False,extD=False,sparse=True,sym=True,irreducible=False,num=False):

    print 'Calculating CH3'
    tag='CH3'
    if(extH):
        print 'with external proton'
        tag+='H'
    if(extD):
        print 'with external deuteron'
        tag+='D'
        sym=False #no symbolic analysis for deuterons

    rot='static'
    #rot='rot'

    inst=CommAux(tag,sparse=sparse,sym=sym) #make instance of class

    if(num==True):#assume tetrahedral arrangement
        import math
        beta=math.acos(-1./3.)
    else: #leave beta as a symbolic parameter
        beta='beta'

    if(ax):
        inst.GetDip('H2','C1','d',beta=beta,alpha='4pi/3',rot=rot)
        inst.GetDip('H3','C1','d',beta=beta,alpha='2pi/3',rot=rot)
        inst.GetDip('H4','C1','d',beta=beta,alpha='0pi/3',rot=rot)
    if(xx):
        inst.GetDip('H3','H2','e',beta='pi/2',alpha='1pi/2',rot=rot)
        inst.GetDip('H4','H2','e',beta='pi/2',alpha='7pi/6',rot=rot)
        inst.GetDip('H4','H3','e',beta='pi/2',alpha='11pi/6',rot=rot)
    if(cx):
        inst.GetCSA('H2','cX',beta=beta,alpha='4pi/3',rot=rot)
        inst.GetCSA('H3','cX',beta=beta,alpha='2pi/3',rot=rot)
        inst.GetCSA('H4','cX',beta=beta,alpha='0pi/3',rot=rot)
    if(ca):
        inst.GetCSA('C1','cA',beta=0,alpha=0,rot=rot)
    if(extH):
        inst.GetDip('H5','H2','f',beta=0,alpha=0,rot='ext')
        inst.GetDip('H5','H3','f',beta=0,alpha=0,rot='ext')
        inst.GetDip('H5','H4','f',beta=0,alpha=0,rot='ext')
        if(extD):
            inst.GetDip('D6','H2','g',beta=0,alpha=0,rot='ext')
            inst.GetDip('D6','H3','g',beta=0,alpha=0,rot='ext')
            inst.GetDip('D6','H4','g',beta=0,alpha=0,rot='ext')
    elif(extD):
        inst.GetDip('D5','H2','g',beta=0,alpha=0,rot='ext')
        inst.GetDip('D5','H3','g',beta=0,alpha=0,rot='ext')
        inst.GetDip('D5','H4','g',beta=0,alpha=0,rot='ext')


    inst.macro=macro

    inst.CrossCorrHam() #proceed to cross correlate

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    inst.tm=10E-12 #s
    inst.tc=10E-9   #s
    inst.pars['beta']=111.6
    inst.pars['beta2']=0.
    inst.pars['R']=1.09E-10,'C','H'
    inst.pars['cX']=1.,'H'
    inst.pars['cA']=20.,'C'
    inst.pars['Rf']=3E-10,'H','H'
    inst.pars['Rg']=3E-10,'H','D'


    inst.SetPars('CH3')

    #  aaa, baa, aba, bba, aab, bab, abb, bbb
    #1                                    bbb
    #2                +bba     +bab  +abb
    #3                -bba     +bab
    #4                +bba     +bab -2abb
    #5     +baa +aba      +aab
    #6          -aba      +aab
    #7    -2baa +aba      +aab
    #8 aaa
    #
    #irreducible representation in terms of cartesian basis
    #normalisation handled in the irreducible basis function
    #P=[[0,0,0,0,0,0,0,1],[0,0,0,1,0,1,1,0],[0,0,0,-1,0,1,0,0],[0,0,0,1,0,1,-2,0],[0,1,1,0,1,0,0,0],[0,0,-1,0,1,0,0,0],[0,-2,1,0,1,0,0,0],[1,0,0,0,0,0,0,0]]
    if(extD==False and extH==False and irreducible==True):
        irrbasis=inst.IreducibleBasis()
        inst.DoTcPlot(1E-6,1E-11,30,irrbasis,'figIrr.eps')
        inst.tc=1E-8
        inst.tm=1E-11
        inst.DoBasisPlot(irrbasis,'figIrr2.eps')


    #make a new basis
    testbasis=inst.GetBasisAXn(3) #assemble aaa,aab,abb,bbb basis

    inst.Assemble(('H4pH3bH2bC1b','H4bH3pH2bC1b','H4bH3bH2pC1b'),'h3')
    inst.Assemble(('H4pH3bH2aC1b','H4pH3aH2bC1b','H4aH3pH2bC1b','H4bH3pH2aC1b','H4aH3bH2pC1b','H4bH3aH2pC1b','H4pH3pH2mC1b','H4pH3mH2pC1b','H4mH3pH2pC1b'),'h2')
    inst.Assemble(('H4pH3aH2aC1b','H4aH3pH2aC1b','H4aH3aH2pC1b',),'h1')
    inst.Assemble(('H4pC1a','H3pC1a','H2pC1a',),'Ha')
    inst.Assemble(('H4pC1b','H3pC1b','H2pC1b',),'Hb')
    inst.Assemble(('H4zC1z','H3zC1z','H2zC1z',),'CzHz')
    inst.Assemble(('H4zH3zC1z','H4zH2zC1z','H3zH2zC1z',),'CzHzHz')
    testbasis.append('Ha')
    testbasis.append('Hb')
    testbasis.append('CzHz')
    testbasis.append('CzHzHz')

    print
    #evaluate relaxation rates of new basis


    #inst.EvalRate('abb','abb',verb='y')  #correct
    #inst.EvalRate('aaa','aaa',verb='y')  #correct
    #inst.CalcRate('aab','abb',verb='y')

    now=datetime.now()
    inst.EvalRate(testbasis,testbasis,verb='y')
    #print inst.tempy #*20./120.*3.
    #sys.exit(100)

    #for lab in testbasis:
    #    inst.EvalRate(lab,lab,verb='y')
    print datetime.now()-now
    #sys.exit(100)
    inst.EvalRate('CzHz','CzHz',verb='y')
    inst.EvalRate('CzHzHz','CzHzHz',verb='y')

    inst.EvalRate('CzHzHz','CzHz',verb='y')


    inst.EvalRate('Ha','Ha',verb='y')
    inst.EvalRate('Hb','Hb',verb='y')
    inst.EvalRate('Hb','Ha',verb='y')
    inst.EvalRate('Ha','Hb',verb='y')

    inst.EvalRate(testbasis,testbasis,verb='n')  #get symbolic rates


    """
    #calculate values.
    import numpy
    vals=numpy.zeros((4,4))
    for tc in 1E-9,1E-8,1E-7:
        for tm in 1E-12,1E-11,1E-10,1E-9:
            inst.tm=tm
            inst.tc=tc   #s
            for i,start in enumerate(testbasis):
                for j,finish in enumerate(testbasis):
                    vals[i,j]=inst.CalcRate(start,finish,verb='n')
            print
            print 'tc:',tc
            print 'tm:',tm
            print vals
    """

    inst.tm=10E-12  #s
    inst.tc=10E-9   #s
    inst.DoBasisPlot(testbasis,'figz.eps')

    inst.tm=10E-12
    autoRates='aaa','aab','abb','bbb','Ha','Hb','CzHz','CzHzHz'    

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    inst.pars['beta']=111.6
    inst.pars['R']=1.09E-10,'C','H'
    inst.pars['cX']=1.,'H'
    inst.pars['cA']=20.,'C'
    inst.pars['Rf']=3E-10,'H','H'
    inst.pars['Rg']=3E-10,'H','D'

    inst.SetPars('CH3')
    inst.DoTcPlot(1E-6,1E-11,30,autoRates,'fig1.eps')
    inst.SetFreq(1200)  #MHz. Set spectrometer proton frequency
    inst.SetPars('CH3')
    inst.DoTcPlot(1E-6,1E-11,30,autoRates,'fig3.eps')

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    inst.pars['beta']=109.5
    inst.pars['R']=1.35E-10,'C','F'
    inst.pars['cX']=140.,'F'
    inst.pars['cA']=20.,'C'
    inst.pars['Rf']=3E-10,'H','F'
    inst.pars['Rg']=3E-10,'H','D'
    inst.SetPars('CH3')
    inst.DoTcPlot(1E-6,1E-11,30,autoRates,'fig2.eps')
    inst.SetFreq(1200)  #MHz. Set spectrometer proton frequency
    inst.SetPars('CH3')
    inst.DoTcPlot(1E-6,1E-11,30,autoRates,'fig4.eps')

    #do proton fast and slow rates
    inst.EvalRate('h1','h1')  #correct
    inst.EvalRate('h2','h2')  #correct
    inst.EvalRate('h3','h3')  #correct

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    hrates='h1','h2','h3'
    inst.pars['beta']=111.6
    inst.pars['R']=1.09E-10,'C','H'
    inst.pars['cX']=1.,'H'
    inst.pars['cA']=20.,'C'
    inst.pars['Rf']=3E-10,'H','H'
    inst.pars['Rg']=3E-10,'H','D'
    inst.SetPars('CH3')
    inst.DoTcPlot(1E-6,1E-11,30,hrates,'fig5.eps')



    #for lab in testbasis:
    #    inst.TestForm(lab,lab,rot)


    inst.MacroTable(rot,3)
    inst.CloseLatex()

def DoCH3waudby(macro=True,ax=True,xx=True,cx=True,ca=True,extH=False,extD=False,sparse=True,sym=True,irreducible=False,num=False):

    print 'Calculating CH3'
    tag='CH3'
    if(extH):
        print 'with external proton'
        tag+='H'
    if(extD):
        print 'with external deuteron'
        tag+='D'
        sym=False #no symbolic analysis for deuterons

    rot='static'
    rot='rot'

    inst=CommAux(tag,sparse=sparse,sym=sym) #make instance of class

    if(num==True):#assume tetrahedral arrangement
        import math
        beta=math.acos(-1./3.)
    else: #leave beta as a symbolic parameter
        beta='beta'

    if(ax):
        inst.GetDip('H2','C1','d',beta=beta,alpha='4pi/3',rot=rot)
        inst.GetDip('H3','C1','d',beta=beta,alpha='2pi/3',rot=rot)
        inst.GetDip('H4','C1','d',beta=beta,alpha='0pi/3',rot=rot)
    if(xx):
        inst.GetDip('H3','H2','e',beta='pi/2',alpha='3pi/2',rot=rot)
        inst.GetDip('H4','H2','e',beta='pi/2',alpha='7pi/6',rot=rot)
        inst.GetDip('H4','H3','e',beta='pi/2',alpha='5pi/6',rot=rot)
    if(cx):
        inst.GetCSA('H2','cX',beta=beta,alpha='4pi/3',rot=rot)
        inst.GetCSA('H3','cX',beta=beta,alpha='2pi/3',rot=rot)
        inst.GetCSA('H4','cX',beta=beta,alpha='0pi/3',rot=rot)
    if(ca):
        inst.GetCSA('C1','cA',beta=0,alpha=0)
    if(extH):
        inst.GetDip('H5','H2','f',beta=0,alpha=0,rot='ext')
        inst.GetDip('H5','H3','f',beta=0,alpha=0,rot='ext')
        inst.GetDip('H5','H4','f',beta=0,alpha=0,rot='ext')
        if(extD):
            inst.GetDip('D6','H2','g',beta=0,alpha=0,rot='ext')
            inst.GetDip('D6','H3','g',beta=0,alpha=0,rot='ext')
            inst.GetDip('D6','H4','g',beta=0,alpha=0,rot='ext')
    elif(extD):
        inst.GetDip('D5','H2','g',beta=0,alpha=0,rot='ext')
        inst.GetDip('D5','H3','g',beta=0,alpha=0,rot='ext')
        inst.GetDip('D5','H4','g',beta=0,alpha=0,rot='ext')


    inst.macro=macro

    inst.CrossCorrHam() #proceed to cross correlate

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    inst.tm=10E-12 #s
    inst.tc=10E-9   #s
    inst.pars['beta']=111.6
    inst.pars['beta2']=0.
    inst.pars['R']=1.09E-10,'C','H'
    inst.pars['cX']=1.,'H'
    inst.pars['cA']=20.,'C'
    inst.pars['Rf']=1E-10,'H','H'
    inst.pars['Rg']=1E-10,'H','D'


    inst.SetPars('CH3')

    #  aaa, baa, aba, bba, aab, bab, abb, bbb
    #1                                    bbb
    #2                +bba     +bab  +abb
    #3                -bba     +bab
    #4                +bba     +bab -2abb
    #5     +baa +aba      +aab
    #6          -aba      +aab
    #7    -2baa +aba      +aab
    #8 aaa
    #
    #irreducible representation in terms of cartesian basis
    #normalisation handled in the irreducible basis function
    #P=[[0,0,0,0,0,0,0,1],[0,0,0,1,0,1,1,0],[0,0,0,-1,0,1,0,0],[0,0,0,1,0,1,-2,0],[0,1,1,0,1,0,0,0],[0,0,-1,0,1,0,0,0],[0,-2,1,0,1,0,0,0],[1,0,0,0,0,0,0,0]]
    #if(extD==False and extH==False and irreducible==True):
    #    irrbasis=inst.IreducibleBasis()
    #    inst.DoTcPlot(1E-6,1E-11,30,irrbasis,'figIrr.eps')
    #    inst.tc=1E-8
    #    inst.tm=1E-11
    #    inst.DoBasisPlot(irrbasis,'figIrr2.eps')


    #make a new basis
    #testbasis=inst.GetBasisAXn(3) #assemble aaa,aab,abb,bbb basis

    #inst.Assemble(('H4pH3bH2bC1b','H4bH3pH2bC1b','H4bH3bH2pC1b'),'h3')
    #inst.Assemble(('H4pH3bH2aC1b','H4pH3aH2bC1b','H4aH3pH2bC1b','H4bH3pH2aC1b','H4aH3bH2pC1b','H4bH3aH2pC1b','H4pH3pH2mC1b','H4pH3mH2pC1b','H4mH3pH2pC1b'),'h2')
    #inst.Assemble(('H4pH3aH2aC1b','H4aH3pH2aC1b','H4aH3aH2pC1b',),'h1')
    #inst.Assemble(('H4pC1a','H3pC1a','H2pC1a',),'Ha')
    #inst.Assemble(('H4pC1b','H3pC1b','H2pC1b',),'Hb')

    inst.Assemble(('H5zH4zC1p','H5zH3zC1p','H5zH2zC1p',),'CpHz5')
    inst.Assemble(('H4zC1p','H3zC1p','H2zC1p',),'CpHz')
    #inst.Assemble(('H4pC1p','H3pC1p','H2pC1p',),'CpHp')
    inst.Assemble(('H4pC1x','H3pC1x','H2xC1x',),'CxHx')
    inst.Assemble(('H5xH4pC1x','H5xH3pC1x','H5xH2xC1x',),'CxHx5')
    #inst.Assemble(('H5zH4pC1x','H5zH3pC1x','H5zH2xC1x',),'CxHxZ')

    testbasis=[]
    testbasis.append('CpHz')
    testbasis.append('CpHz5')
    #testbasis.append('CpHp')
    testbasis.append('CxHx')
    testbasis.append('CxHx5')
    #testbasis.append('CxHxZ')

    for lab in testbasis:
        inst.EvalRate(lab,lab,verb='y')  #get symbolic rates

    inst.tm=10E-12  #s
    inst.tc=10E-9   #s
    #inst.DoBasisPlot(testbasis,'figz.eps')
    #autoRates='aaa','aab','abb','bbb','Ha','Hb','CzHz','CzHzHz'    

    #inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    #inst.pars['beta']=111.6
    #inst.pars['R']=1.09E-10,'C','H'
    #inst.pars['cX']=1.,'H'
    #inst.pars['cA']=20.,'C'
    #inst.pars['Rf']=3E-10,'H','H'
    #inst.pars['Rg']=3E-10,'H','D'
    #inst.SetPars('CH3')
    inst.DoTcPlot(1E-6,1E-11,30,testbasis,'fig1.eps')
    inst.SetFreq(1200)  #MHz. Set spectrometer proton frequency
    inst.SetPars('CH3')
    inst.DoTcPlot(1E-6,1E-11,30,testbasis,'fig3.eps')


    inst.CloseLatex()



def DoCD3(macro=True,ax=True,xx=True,cx=True,ca=True,ext=True,qd=True,sparse=True,sym=True):

    print 'Calculating CD3'
    if(qd): #no symbolic mode for D
        sym=False
        point=False

    rot='static'
    rot='rot'

    if(ext):
        print 'with external proton'
        inst=CommAux('CD3H',sparse=sparse,sym=sym) #make instance of class
    else:
        inst=CommAux('CD3',sparse=sparse,sym=sym) #make instance of class

    if(ax):
        inst.GetDip('D2','C1','d',beta='beta',alpha='4pi/3',rot=rot)
        inst.GetDip('D3','C1','d',beta='beta',alpha='2pi/3',rot=rot)
        inst.GetDip('D4','C1','d',beta='beta',alpha='0pi/3',rot=rot)
    if(xx):
        inst.GetDip('D3','D2','e',beta='pi/2',alpha='3pi/2',rot=rot)
        inst.GetDip('D4','D2','e',beta='pi/2',alpha='7pi/6',rot=rot)
        inst.GetDip('D4','D3','e',beta='pi/2',alpha='5pi/6',rot=rot)
    if(cx):
        inst.GetCSA('D2','cX',beta='beta',alpha='4pi/3',rot=rot)
        inst.GetCSA('D3','cX',beta='beta',alpha='2pi/3',rot=rot)
        inst.GetCSA('D4','cX',beta='beta',alpha='0pi/3',rot=rot)
    if(ca):
        inst.GetCSA('C1','cA',beta=0,alpha=0,rot=rot)
    if(ext):
        inst.GetDip('H5','D2','f',beta=0,alpha=0,rot=rot)
        inst.GetDip('H5','D3','f',beta=0,alpha=0,rot=rot)
        inst.GetDip('H5','D4','f',beta=0,alpha=0,rot=rot)

    inst.macro=macro

    inst.CrossCorrHam() #proceed to cross correlate

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    inst.tm=10E-12 #s
    inst.tc=10E-9   #s

    inst.pars['beta']=111.6
    inst.pars['R']=1.09E-10,'C','H'
    inst.pars['cX']=1.,'H'
    inst.pars['cA']=20.,'C'
    inst.pars['Rf']=3E-10,'H','H'
    inst.SetPars('CD3')

    #  aaa, baa, aba, bba, aab, bab, abb, bbb
    #1                                    bbb
    #2                +bba     +bab  +abb
    #3                -bba     +bab
    #4                +bba     +bab -2abb
    #5     +baa +aba      +aab
    #6          -aba      +aab
    #7    -2baa +aba      +aab
    #8 aaa
    #
    #irreducible representation in terms of cartesian basis
    #normalisation handled in the irreducible basis function
    #P=[[0,0,0,0,0,0,0,1],[0,0,0,1,0,1,1,0],[0,0,0,-1,0,1,0,0],[0,0,0,1,0,1,-2,0],[0,1,1,0,1,0,0,0],[0,0,-1,0,1,0,0,0],[0,-2,1,0,1,0,0,0],[1,0,0,0,0,0,0,0]]
    #if(ext==False):
    #    inst.IreducibleBasis(P,compy='n')

    #make a new basis
    testbasis=inst.GetBasisAXn(3) #assemble aaa,aab,abb,bbb basis

    inst.Assemble(('H4pH3bH2bC1b','H4bH3pH2bC1b','H4bH3bH2pC1b'),'h3')
    inst.Assemble(('H4pH3bH2aC1b','H4pH3aH2bC1b','H4aH3pH2bC1b','H4bH3pH2aC1b','H4aH3bH2pC1b','H4bH3aH2pC1b'),'h2')
    inst.Assemble(('H4pH3aH2aC1b','H4aH3pH2aC1b','H4aH3aH2pC1b',),'h1')
    inst.Assemble(('H4pC1a','H3pC1a','H2pC1a',),'Ha')
    inst.Assemble(('H4pC1b','H3pC1b','H2pC1b',),'Hb')
    inst.Assemble(('H4zC1z','H3zC1z','H2zC1z',),'CzHz')
    inst.Assemble(('H4zH3zC1z','H4zH2zC1z','H3zH2zC1z',),'CzHzHz')
    
    print
    #evaluate relaxation rates of new basis


    #inst.EvalRate('abb','abb',verb='y')  #correct
    #inst.EvalRate('aaa','aaa',verb='y')  #correct
    #inst.CalcRate('aab','abb',verb='y')

    now=datetime.now()
    for lab in testbasis:
        inst.EvalRate(lab,lab,verb='y')
    print datetime.now()-now
    #sys.exit(100)
    inst.EvalRate('CzHz','CzHz',verb='y')
    inst.EvalRate('CzHzHz','CzHzHz',verb='y')
    inst.EvalRate('Ha','Ha',verb='y')
    inst.EvalRate('Hb','Hb',verb='y')

    inst.EvalRate(testbasis,testbasis,verb='n')  #get symbolic rates


    """
    #calculate values.
    import numpy
    vals=numpy.zeros((4,4))
    for tc in 1E-9,1E-8,1E-7:
        for tm in 1E-12,1E-11,1E-10,1E-9:
            inst.tm=tm
            inst.tc=tc   #s
            for i,start in enumerate(testbasis):
                for j,finish in enumerate(testbasis):
                    vals[i,j]=inst.CalcRate(start,finish,verb='n')
            print
            print 'tc:',tc
            print 'tm:',tm
            print vals
    """

    inst.tm=10E-12  #s
    inst.tc=10E-9   #s
    inst.DoBasisPlot(testbasis,'figz.eps')

    inst.tm=10E-12
    autoRates='aaa','aab','abb','bbb','Ha','Hb','CzHz','CzHzHz'    

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    inst.pars['beta']=111.6
    inst.pars['R']=1.09E-10,'C','H'
    inst.pars['cX']=1.,'H'
    inst.pars['cA']=20.,'C'
    inst.pars['Rf']=3E-10,'H','H'
    inst.SetPars('CH3')
    inst.DoTcPlot(1E-6,1E-11,30,autoRates,'fig1.eps')
    inst.SetFreq(1200)  #MHz. Set spectrometer proton frequency
    inst.SetPars('CH3')
    inst.DoTcPlot(1E-6,1E-11,30,autoRates,'fig3.eps')

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    inst.pars['beta']=109.5
    inst.pars['R']=1.35E-10,'C','F'
    inst.pars['cX']=140.,'F'
    inst.pars['cA']=20.,'C'
    inst.pars['Rf']=3E-10,'H','F'
    inst.SetPars('CH3')
    inst.DoTcPlot(1E-6,1E-11,30,autoRates,'fig2.eps')
    inst.SetFreq(1200)  #MHz. Set spectrometer proton frequency
    inst.SetPars('CH3')
    inst.DoTcPlot(1E-6,1E-11,30,autoRates,'fig4.eps')

    #do proton fast and slow rates
    inst.EvalRate('h1','h1')  #correct
    inst.EvalRate('h2','h2')  #correct
    inst.EvalRate('h3','h3')  #correct

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    hrates='h1','h2','h3'
    inst.pars['beta']=111.6
    inst.pars['R']=1.09E-10,'C','H'
    inst.pars['cX']=1.,'H'
    inst.pars['cA']=20.,'C'
    inst.pars['Rf']=3E-10,'H','H'
    inst.SetPars('CH3')
    inst.DoTcPlot(1E-6,1E-11,30,hrates,'fig5.eps')

    inst.MacroTable('rot',3)

    inst.CloseLatex()


#################################
def DoCHD2(macro=True,ax=True,xx=True,cx=True,ca=True,ext=True,qd=True,sparse=True,sym=True):

    print
    print 'Calculating CHD2'
    if(qd): #no symbolic mode for D
        sym=False
        point=False

    rot='static'
    rot='rot'

    inst=CommAux('CHD2',sym=sym,sparse=sparse) #make instance of class
    
    #inst.CheckFreePrecession('D3z','D3mC1z',3.1415*2.3*6)
    if(ax):
        inst.GetDip('H2','C1','d',beta='beta',alpha='8pi/6',rot=rot)
        inst.GetDip('D3','C1','e',beta='beta',alpha='4pi/6',rot=rot)
        inst.GetDip('D4','C1','e',beta='beta',alpha='0pi/6',rot=rot)
    if(xx):
        inst.GetDip('D3','H2','f',beta='pi/2',alpha='3pi/2',rot=rot)
        inst.GetDip('D4','H2','f',beta='pi/2',alpha='7pi/6',rot=rot)
        inst.GetDip('D4','D3','g',beta='pi/2',alpha='5pi/6',rot=rot)
    if(ca):
        inst.GetCSA('C1','cC',beta=0,alpha=0,rot=rot)
    if(cx):
        inst.GetCSA('H2','cH',beta='beta',alpha='4pi/3',rot=rot)
        inst.GetCSA('D3','cD',beta='beta',alpha='2pi/3',rot=rot)
        inst.GetCSA('D4','cD',beta='beta',alpha='0pi/3',rot=rot)
    if(qd):
        inst.GetQuad('D3','Q',beta='beta',alpha='4pi/6',rot=rot)
        inst.GetQuad('D4','Q',beta='beta',alpha='0pi/6',rot=rot)
    
    inst.macro=macro
    inst.CrossCorrHam() #proceed to cross correlate

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    inst.pars['beta']=111.4
    inst.pars['Rh']=1.09E-10,'C','H'
    inst.pars['Rd']=1.09E-10,'C','D'
    inst.pars['Rf']=1.09E-10,'H','D'
    inst.pars['Rg']=1.09E-10,'D','D'

    inst.pars['cH']=1.,'H'
    inst.pars['cD']=1.,'D'
    inst.pars['cC']=20.,'C'
    inst.pars['Rf']=3E-10,'H','F'
    inst.pars['Q']=3E-10
    inst.SetPars('CHD2')

    testBasis=inst.GetBasisAXn(3)  #work out A+ eigenbasis
    for lab in testBasis:  #calculate autorelaxation rates for eigenbasis
        inst.EvalRate(lab,lab) #get auto rates

    #  aaa, baa, aba, bba, aab, bab, abb, bbb
    #1                                    bbb
    #2                +bba     +bab  +abb
    #3                -bba     +bab
    #4                +bba     +bab -2abb
    #5     +baa +aba      +aab
    #6          -aba      +aab
    #7    -2baa +aba      +aab
    #8 aaa
    #
    #irreducible representation in terms of cartesian basis
    #normalisation handled in the irreducible basis function
    #P=[[0,0,0,0,0,0,0,1],[0,0,0,1,0,1,1,0],[0,0,0,-1,0,1,0,0],[0,0,0,1,0,1,-2,0],[0,1,1,0,1,0,0,0],[0,0,-1,0,1,0,0,0],[0,-2,1,0,1,0,0,0],[1,0,0,0,0,0,0,0]]
    #inst.IreducibleBasis(P,compy='n')
    
    inst.EvalRate('D4zD3zH2zC1p','D4zD3zH2zC1p')  #correct
    inst.EvalRate('H2aC1p','H2aC1p')  #correct

    inst.DoTcPlot(1E-6,1E-11,30,testBasis,'figCHD2.eps')


    """
    #make a new basis
    inst.Assemble(('D3aD2bH1bC1p','D3bD2aH1bC1p','D3bD2bH1aC1p'),'abb')
    inst.Assemble(('D3aD2aH1bC1p','D3aD2bH1aC1p','D3bD2aH1aC1p'),'aab')
    inst.Assemble(('D3aD2aH1aC1p',),'aaa')
    inst.Assemble(('D3bD2bH1bC1p',),'bbb')
    print
    #evaluate relaxation rates of new basis
    inst.EvalRate('abb','abb')  #correct
    inst.EvalRate('aab','aab')  #correct
    inst.EvalRate('abb','aab')  #correct
    inst.EvalRate('aaa','aaa')  #correct
    inst.EvalRate('bbb','bbb')  #correct
    inst.EvalRate('D3aD2aH1aC1p','D3aD2aH1aC1p')  #correct
    inst.EvalRate('D3aD2aH1bC1p','D3aD2aH1bC1p')  #correct
    inst.EvalRate('D3aD2bH1aC1p','D3aD2bH1aC1p')  #correct
    inst.EvalRate('D3aD2aH1bC1p','D3aD2aH1bC1p')  #correct
    inst.EvalRate('D3aD2bH1bC1p','D3aD2bH1bC1p')  #correct
    inst.EvalRate('D3bD2bH1bC1p','D3bD2bH1bC1p')  #correct
    """
    inst.MacroTable('rot',3)
    inst.CloseLatex()


#################################
def DoCH2D(macro=True,ax=True,xx=True,cx=True,ca=True,ext=True,qd=True,sparse=True,sym=True):

    print
    print 'Calculating CH2D'
    if(qd): #no symbolic mode for D
        sym=False
        point=False

    rot='static'
    rot='rot'

    inst=CommAux('CH2D',sym=sym,sparse=sparse) #make instance of class
    
    #inst.CheckFreePrecession('D3z','D3mC1z',3.1415*2.3*6)
    if(ax):
        inst.GetDip('H2','C1','d',beta='beta',alpha='8pi/6',rot=rot)
        inst.GetDip('H3','C1','e',beta='beta',alpha='4pi/6',rot=rot)
        inst.GetDip('D4','C1','e',beta='beta',alpha='0pi/6',rot=rot)
    if(xx):
        inst.GetDip('H3','H2','f',beta='pi/2',alpha='3pi/2',rot=rot)
        inst.GetDip('D4','H2','g',beta='pi/2',alpha='7pi/6',rot=rot)
        inst.GetDip('D4','H3','g',beta='pi/2',alpha='5pi/6',rot=rot)
    if(ca):
        inst.GetCSA('C1','cC',beta=0,alpha=0,rot=rot)
    if(cx):
        inst.GetCSA('H2','cH',beta='beta',alpha='4pi/3',rot=rot)
        inst.GetCSA('H3','cH',beta='beta',alpha='2pi/3',rot=rot)
        inst.GetCSA('D4','cD',beta='beta',alpha='0pi/3',rot=rot)
    if(qd):
        inst.GetQuad('D4','Q',beta='beta',alpha='0pi/6',rot=rot)
    
    inst.macro=macro
    inst.CrossCorrHam() #proceed to cross correlate

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    inst.pars['beta']=111.4
    inst.pars['Rh']=1.09E-10,'C','H'
    inst.pars['Rd']=1.09E-10,'C','D'
    inst.pars['Rf']=1.09E-10,'H','H'
    inst.pars['Rg']=1.09E-10,'D','H'

    inst.pars['cH']=1.,'H'
    inst.pars['cD']=1.,'D'
    inst.pars['cC']=20.,'C'
    inst.pars['Rf']=3E-10,'H','F'
    inst.pars['Q']=3E-10
    inst.SetPars('CH2D')

    testBasis=inst.GetBasisAXn(3)  #work out A+ eigenbasis
    for lab in testBasis:  #calculate autorelaxation rates for eigenbasis
        inst.EvalRate(lab,lab) #get auto rates

    #  aaa, baa, aba, bba, aab, bab, abb, bbb
    #1                                    bbb
    #2                +bba     +bab  +abb
    #3                -bba     +bab
    #4                +bba     +bab -2abb
    #5     +baa +aba      +aab
    #6          -aba      +aab
    #7    -2baa +aba      +aab
    #8 aaa
    #
    #irreducible representation in terms of cartesian basis
    #normalisation handled in the irreducible basis function
    #P=[[0,0,0,0,0,0,0,1],[0,0,0,1,0,1,1,0],[0,0,0,-1,0,1,0,0],[0,0,0,1,0,1,-2,0],[0,1,1,0,1,0,0,0],[0,0,-1,0,1,0,0,0],[0,-2,1,0,1,0,0,0],[1,0,0,0,0,0,0,0]]
    #inst.IreducibleBasis(P,compy='n')
    
    inst.EvalRate('H2aC1p','H2aC1p')  #correct

    inst.DoTcPlot(1E-6,1E-11,30,testBasis,'figCH2D.eps')


    """
    #make a new basis
    inst.Assemble(('D3aD2bH1bC1p','D3bD2aH1bC1p','D3bD2bH1aC1p'),'abb')
    inst.Assemble(('D3aD2aH1bC1p','D3aD2bH1aC1p','D3bD2aH1aC1p'),'aab')
    inst.Assemble(('D3aD2aH1aC1p',),'aaa')
    inst.Assemble(('D3bD2bH1bC1p',),'bbb')
    print
    #evaluate relaxation rates of new basis
    inst.EvalRate('abb','abb')  #correct
    inst.EvalRate('aab','aab')  #correct
    inst.EvalRate('abb','aab')  #correct
    inst.EvalRate('aaa','aaa')  #correct
    inst.EvalRate('bbb','bbb')  #correct
    inst.EvalRate('D3aD2aH1aC1p','D3aD2aH1aC1p')  #correct
    inst.EvalRate('D3aD2aH1bC1p','D3aD2aH1bC1p')  #correct
    inst.EvalRate('D3aD2bH1aC1p','D3aD2bH1aC1p')  #correct
    inst.EvalRate('D3aD2aH1bC1p','D3aD2aH1bC1p')  #correct
    inst.EvalRate('D3aD2bH1bC1p','D3aD2bH1bC1p')  #correct
    inst.EvalRate('D3bD2bH1bC1p','D3bD2bH1bC1p')  #correct
    """
    inst.MacroTable('rot',3)
    inst.CloseLatex()

#################################
def DoCHn(geometry,basis,macro=True,ax=True,xx=True,cx=True,ca=True,sparse=True,sym=True,irreducible=False):
    import re
    print
    n=int(re.findall('\d+', basis)[0])
    print 'Calculating ',geometry,basis,'X:',n

    inst=CommAux(basis,sparse=sparse,sym=sym) #C....H  #initialise class
    inst.CYCLIC=False#True #helpful for symmetric complexes. reduces basis size
    inst.macro=macro
    
    rot='rot'
    rot='static'

    vv=inst.GetGeometry(geometry)  #set geometry according to tag
    if(ax):
        inst.AddDipolarAX(vv,rot=rot)     #add AX dipolars 
    if(xx):
        inst.AddDipolarXX(vv,rot=rot)  #add XX dipolars 
    if(cx):
        inst.AddXCSA(vv,rot=rot)         #add X CSAs
    if(ca):
        inst.AddACSA(vv,rot=rot)         #add S CSAs

    print 'relative distances:',inst.edict    
    inst.CrossCorrHam() #build libraries

    inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    inst.pars['beta']=109.47
    inst.pars['R']=1.35E-10,'C','F'
    inst.pars['cX']=140.,'F'
    inst.pars['cA']=20.*0,'C'
    inst.pars['Rf']=3E-10,'H','H'
    inst.pars['Q']=3E-10
    inst.SetPars(basis)

    #TRANSFORM INTO IRREDUCIBLE REPRESENTATION & GET RATES
    if(irreducible):
        irrbasis=inst.IreducibleBasis()
        inst.DoTcPlot(1E-6,1E-11,30,irrbasis,'figIrr.eps')
        inst.tc=1E-8
        inst.tm=1E-11
        inst.DoBasisPlot(irrbasis,'figIrr2.eps')


    testBasis=inst.GetBasisAXn(n)  #work out A+ eigenbasis

    b=[]
    for i in range(n):
        b.append('H'+str(i+2)+'pC1a')
    inst.Assemble(b,'Ha')

    b=[]
    for i in range(n):
        b.append('H'+str(i+2)+'pC1b')
    inst.Assemble(b,'Hb')
    #testBasis=[]
    testBasis.append('Ha')
    testBasis.append('Hb')

    b=[]
    for i in range(n):
        b.append('H'+str(i+2)+'zC1z')
    inst.Assemble(b,'CzHz')
    b=[]
    for i in range(n):
        for j in range(n):
            if(j>i):
                b.append('H'+str(j+2)+'zH'+str(i+2)+'zC1z')
    inst.Assemble(b,'CzHzHz')
    #testBasis=[]
    testBasis.append('CzHz')
    testBasis.append('CzHzHz')


    #inst.EvalRate('C1x','C1x',calc='y') #get auto rates
    #sys.exit(100)
    import pp
    ncpus=4
    ppservers = ()
    job_server = pp.Server(ncpus, ppservers=ppservers)

    import copy
    onst=[]
    for i in range(len(testBasis)):
        onst.append(copy.deepcopy(inst))

    jobs = [(i, job_server.submit(onst[i].EvalRate,(lab,lab,),globals=globals())) for i,lab in enumerate(testBasis)]
    for inny,job in jobs:
        job()
        inst.resSet.update(onst[inny].resSet)




    
    #for lab in testBasis:  #calculate autorelaxation rates for eigenbasis
    #    now=datetime.now()
    #    inst.EvalRate(lab,lab,calc='y',verb='y') #get auto rates
    #    print datetime.now()-now


    #inst.SetFreq(600)  #MHz. Set spectrometer proton frequency
    #inst.pars['beta']=109.47
    #inst.pars['R']=1.35E-10,'C','F'
    #inst.pars['cX']=140.,'F'
    #inst.pars['cA']=20.*0,'C'
    #inst.pars['Rf']=3E-10,'H','H'
    #inst.pars['Q']=3E-10
    inst.SetPars(basis)
    inst.DoTcPlot(1E-6,1E-11,30,testBasis,'fig'+basis+'.eps',geometry+'.eps')
    #inst.EvalRate(testBasis,testBasis,calc='y',verb='y') #get auto rates
    #inst.tc=1E-8
    #inst.tm=1E-11
    #inst.DoBasisPlot(testBasis,'figIrr2a.eps')

    #inst.tc=10E-9  #work out all cross relaxations in eigenbase
    #DoBasisPlot(inst,testBasis,'figz.eps')


    for lab in testBasis:
        inst.TestForm(lab,lab,'static')

    inst.MacroTable('static',n)
    inst.CloseLatex()

###################################################
      

#find non-zero elements and work out corresponding operator
#experimental. should loop over matrix and find non-zero elements.
def WhoAmI(a,verb='n'):
    import numpy
    verb='y'
    #print a.shape
    rows,cols=a.nonzero() #get all nonzero dudes.
    if(verb=='y'):
        print
        print 'analysing'
        print a.shape
        print a
    
    g=3,2

    reps=[]
    for row,col in zip(rows,cols):
        aa=row
        bb=col
        #print 'non-zero element:',aa,bb,a[aa,bb]
        sz=a.shape[0]
        bis=[]
        cnt=0
        while(sz>=2):
            #print '   ',aa,bb,bis,sz
            if(g[-1-cnt]==2):
                if(aa>sz/2-1):
                    aa-=(sz/2)
                    if(bb>sz/2-1):
                        bb-=(sz/2)
                        bis.append('b')
                        #print 'b'
                    else:
                        bis.append('m')
                        #print 'm'
                else:
                    if(bb>sz/2-1):
                        bb-=(sz/2)
                        bis.append('p')
                        #print 'p'
                    else:
                        bis.append('a')
                        #print 'a'
                sz=sz/2
                cnt+=1
                #print 'bis',bis
            else:
                #print '   1',aa,bb,bis,sz
                if(aa<sz/3):
                    if(bb<sz/3):
                        bis.append('1')
                    elif(bb<2*sz/3):
                        bis.append('2')
                        bb-=sz/3.
                    else:
                        bis.append('3')
                        bb-=2*sz/3

                elif(aa<2*sz/3):
                    aa-=sz/3.
                    if(bb<sz/3):
                        bis.append('4')
                    elif(bb<2*sz/3):
                        bis.append('5')
                        bb-=sz/3.
                    else:
                        bis.append('6')
                        bb-=2*sz/3

                else:
                    aa-=2*sz/3.
                    if(bb<sz/3):
                        bis.append('7')
                    elif(bb<2*sz/3):
                        bis.append('8')
                        bb-=sz/3.
                    else:
                        bis.append('9')
                        bb-=2*sz/3

                sz=sz/3
                cnt+=1
                #print 'bis',bis
        bis=numpy.array(bis)
        #print a[row,col],row,col
        if(numpy.fabs(a[row,col].real)>1E-6 or numpy.fabs(a[row,col].imag)>1E-6):
            if(verb=='y'):
                print 'element:',bis.tostring(),'values:',row,col,a[row,col]
                #labby=self.GetLabelPure(bis[1:],self.baseSize-1)            
            reps.append((a[row,col],bis,1,1,bis.tostring()))
    #for rep in reps:
    #    print rep
    return reps



def DoDComm():
    import numpy
    from basis import GetBasis
    inst=CommAux('CD',sparse=True,sym=False) #C....H  #initialise class
    inst.base=GetBasis('CD',Sparse=True)  #get complete basis  
    inst.GetDip('D2','C1','d',beta=0,alpha=0) #all dipolar 
    inst.GetCSA('C1','cA',beta=0,alpha=0)     #all dipolar-CSA
    inst.GetCSA('D2','cX',beta=0,alpha=0)     #all dipolar-CSA

    n1=numpy.array(inst.Aint[0])[:,1] #operators 1
    n2=numpy.array(inst.Aint[1])[:,1] #operators 2
    n3=numpy.array(inst.Aint[2])[:,1] #operators 3
    basisDip=numpy.concatenate((n1,n2,n3)) #all possible operators

    #WhoAmI(inst.base['C1a'])
    #WhoAmI(inst.base['D2pC1a'])
    #WhoAmI(inst.base['D2p'])
    #for key,vals in inst.base.items():
    #    print key,vals
    #    WhoAmI(vals)
    #sys.exit(10)

    from basis import comm
    from basis import compare

    print 'making database of sums and differences'
    refbase={} #make a reference database including all sums and differences of operators
    for key,vals in inst.base.items():
        for koi,vols in inst.base.items():
            if(key!=koi):
                tast=vals+vols
                refbase[key+'P'+koi]=tast
                tast=vals-vols
                refbase[key+'M'+koi]=tast


    outy=open('test.txt','w')
    for key,vals in inst.base.items(): #loop over all operators
        for dip in basisDip:  #for all Hamiltonian operators
            comm1=comm(inst.base[dip],vals) #do numerical commutator 1
            if(inst.IsZero(comm1)==0): #if not zero... find its symbolic identity
                frac,dom,resy,baso=compare(comm1,inst.base,maxy=4,even=True)
                if(resy=='none'): #have another go. #try again using the sums and differences database
                    frac,dom,resy,baso=compare(comm1,refbase,maxy=4,even=True)
                if(resy=='none'): #no symbolic operator for the result.
                    print
                    print 'shit'
                    print '[',dip,',',key,']=',frac,dom,resy
                    print resy,baso
                    WhoAmI(baso)
                    print
                    sys.exit(100)
                else: #success. print to file
                    #print key
                    #op1=inst.GetTrSym(key)
                    #op2=inst.GetTrSym(dip)
                    #op4=inst.GetTrSym(resy)
                    op1=inst.GetOp(key).tostring()
                    op2=inst.GetOp(dip).tostring()
                    op4=inst.GetOp(resy).tostring()
                    #print '[',key,',',koi,']=',frac,dom,resy
                    if(frac.denominator==1):
                        num=str(frac.numerator)
                    else:
                        num=str(frac.numerator)+'/'+str(frac.denominator)
                    if(dom=='i'):
                        num+='i'
                    #print
                    line ='['+dip+','+key+']='+num+'('+resy+')'
                    print line
                    line='['+op2+','+op1+']='+num+'('+op4+')'
                    outy.write(line+'\n')
                    print line
                                
                    #test commutator
                    nom=float(frac.numerator)/float(frac.denominator)
                    if(dom=='i'):
                        nom*=complex(0,1)

                    if(resy in inst.base.keys()):
                        if(inst.IsZero(comm1-nom*inst.base[resy])==False):
                            pass
                            #print 'shit'
                            #print comm1
                            #print nom*inst.base[resy]
                            #sys.exit(100)
                        else:
                            print 'True'
                    if(resy in refbase.keys()):
                        if(inst.IsZero(comm1-nom*refbase[resy])==False):
                            print 'shit'
                            print comm1
                            print nom*inst.base[resy]
                            sys.exit(100)
                        else:
                            print 'True'
    outy.close()
 




    print inst.base.keys()
###############################################################
#Here we go....

#Functions to setup symbolic libraries
#MakeSingleCommutatorLibrary(): 
#MakeDoubleCommutatorLibrary():
#MakeSingleTraceLibrary():
#CommutatorTest()


#DoCommTest2()
#from commAux import *
##MakeDoubleCommutatorLibrary()
#DoCommTest4()
#sys.exit(100)

#DoDComm()

#DoCHtest()

#DoCH3(macro=False,ax=True,xx=True,cx=True,ca=True,extH=True,extD=False,sparse=True,sym=True)
#DoCH3waudby(macro=True,ax=True,xx=True,cx=True,ca=True,extH=False,extD=False,sparse=True,sym=True)

#DoCH(macro=False,ax=True,xx=True,cx=True,ca=True,sparse=True,sym=True)
#DoCD(macro=False,ax=True,xx=True,cx=True,ca=True,qx=True,sparse=True,sym=False)

#DoCH2(macro=False,ax=True,xx=True,cx=True,ca=True,extH=False,extD=False,sparse=True,sym=True,irreducible=False)
DoCH3(macro=False,ax=True,xx=True,cx=True,ca=True,extH=True,extD=False,sparse=True,sym=True,num=False)

#DoCHD2(macro=False,ax=True,xx=True,cx=True,ca=True,ext=False,qd=True,sparse=True,sym=True)
#DoCH2D(macro=False,ax=True,xx=True,cx=True,ca=True,ext=False,qd=True,sparse=True,sym=True)
#DoCD3(macro=False,ax=True,xx=True,cx=True,ca=True,ext=True,qd=True,sparse=True,sym=True)


#DoCHn('tetrahedron','CH4',ax=True,xx=True,cx=True,ca=False,macro=False,sym=True,irreducible=False)
#DoCHn('octahedron','CH6',ax=True,xx=True,cx=True,ca=False,macro=False,sym=True,irreducible=False)
#DoCHn('cube','CH8',ax=True,xx=True,cx=True,ca=False,macro=False,sym=True,irreducible=False)

#DoCHn('icosahedron','CH12',ax=True,xx=True,cx=True,ca=False,macro=True,sparse=True,sym=True,irreducible=False)


#DoCHn('dodecahedron','CH20',ax=True,xx=False,cx=False,ca=False,macro=True,sparse=True,sym=True)



